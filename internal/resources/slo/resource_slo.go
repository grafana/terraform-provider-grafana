package slo

import (
	"context"
	"encoding/json"
	"fmt"
	"regexp"

	"github.com/grafana/slo-openapi-client/go/slo"
	"github.com/grafana/terraform-provider-grafana/v4/internal/common"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

const (
	QueryTypeFreeform       string = "freeform"
	QueryTypeHistogram      string = "histogram"
	QueryTypeRatio          string = "ratio"
	QueryTypeThreshold      string = "threshold"
	QueryTypeGrafanaQueries string = "grafanaQueries"

	// Asserts integration constants
	AssertsProvenanceLabel = "grafana_slo_provenance"
	AssertsProvenanceValue = "asserts"
	AssertsRequestHeader   = "Grafana-Asserts-Request"
)

var (
	resourceSloID = common.NewResourceID(common.StringIDField("uuid"))

	_ resource.Resource                     = &sloResource{}
	_ resource.ResourceWithConfigure        = &sloResource{}
	_ resource.ResourceWithImportState      = &sloResource{}
	_ resource.ResourceWithConfigValidators = &sloResource{}
)

func resourceSlo() *common.Resource {
	return common.NewResource(
		common.CategorySLO,
		"grafana_slo",
		resourceSloID,
		&sloResource{},
	).WithLister(listSlos).WithPreferredResourceNameField("name")
}

type sloResource struct {
	basePluginFrameworkResource
}

func (r *sloResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = "grafana_slo"
}

func (r *sloResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: `
Resource manages Grafana SLOs (Service Level Objectives).

* [Official documentation](https://grafana.com/docs/grafana-cloud/alerting-and-irm/slo/)
* [API documentation](https://grafana.com/docs/grafana-cloud/alerting-and-irm/slo/api/)
* [Additional Information On Alerting Rule Annotations and Labels](https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/#templating/)
`,
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:    true,
				Description: "The Terraform resource ID (same as UUID).",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"uuid": schema.StringAttribute{
				Optional:    true,
				Computed:    true,
				Description: "UUID for the SLO. Custom UUIDs can be set. If not provided, a random UUID will be generated by the API.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"name": schema.StringAttribute{
				Required:    true,
				Description: "Name should be a short description of your indicator. Consider names like \"API Availability\"",
				Validators: []validator.String{
					stringvalidator.LengthBetween(0, 128),
				},
			},
			"description": schema.StringAttribute{
				Required:    true,
				Description: "Description is a free-text field that can provide more context to an SLO.",
				Validators: []validator.String{
					stringvalidator.LengthBetween(0, 1024),
				},
			},
			"folder_uid": schema.StringAttribute{
				Optional:    true,
				Description: "UID for the SLO folder",
			},
			"search_expression": schema.StringAttribute{
				Optional:    true,
				Description: "The name of a search expression in Grafana Asserts. This is used in the SLO UI to open the Asserts RCA workbench and in alerts to link to the RCA workbench.",
			},
		},
		Blocks: map[string]schema.Block{
			"destination_datasource": schema.ListNestedBlock{
				MarkdownDescription: "Destination Datasource sets the datasource defined for an SLO",
				Validators: []validator.List{
					listvalidator.SizeAtLeast(1),
					listvalidator.SizeAtMost(1),
				},
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"uid": schema.StringAttribute{
							Required:    true,
							Description: "UID for the Datasource",
						},
					},
				},
			},
			"query": schema.ListNestedBlock{
				MarkdownDescription: "Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported.",
				Validators: []validator.List{
					listvalidator.SizeAtLeast(1),
				},
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"type": schema.StringAttribute{
							Required:    true,
							Description: "Query type must be one of: \"freeform\", \"query\", \"ratio\", \"grafana_queries\" or \"threshold\"",
							Validators: []validator.String{
								stringvalidator.OneOf("freeform", "query", "ratio", "threshold", "grafana_queries"),
							},
						},
					},
					Blocks: map[string]schema.Block{
						"freeform": schema.ListNestedBlock{
							MarkdownDescription: "Freeform query configuration.",
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"query": schema.StringAttribute{
										Required:    true,
										Description: "Freeform Query Field - valid promQl",
									},
								},
							},
						},
						"grafana_queries": schema.ListNestedBlock{
							MarkdownDescription: "Array for holding a set of grafana queries",
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"grafana_queries": schema.StringAttribute{
										Required:    true,
										Description: "Query Object - Array of Grafana Query JSON objects",
									},
								},
							},
						},
						"ratio": schema.ListNestedBlock{
							MarkdownDescription: "Ratio query configuration.",
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"success_metric": schema.StringAttribute{
										Required:    true,
										Description: "Counter metric for success events (numerator)",
									},
									"total_metric": schema.StringAttribute{
										Required:    true,
										Description: "Metric for total events (denominator)",
									},
									"group_by_labels": schema.ListAttribute{
										Optional:    true,
										Description: "Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - \"^[a-zA-Z_][a-zA-Z0-9_]*$\"",
										ElementType: types.StringType,
									},
								},
							},
						},
					},
				},
			},
			"label": schema.ListNestedBlock{
				MarkdownDescription: "Additional labels that will be attached to all metrics generated from the query. These labels are useful for grouping SLOs in dashboard views that you create by hand. Labels must adhere to Prometheus label name schema - \"^[a-zA-Z_][a-zA-Z0-9_]*$\"",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Required:    true,
							Description: "Key for filtering and identification",
						},
						"value": schema.StringAttribute{
							Required:    true,
							Description: "Templatable value",
						},
					},
				},
			},
			"objectives": schema.ListNestedBlock{
				MarkdownDescription: "Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget.",
				Validators: []validator.List{
					listvalidator.SizeAtLeast(1),
				},
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"value": schema.Float64Attribute{
							Required:    true,
							Description: "Value between 0 and 1. If the value of the query is above the objective, the SLO is met.",
						},
						"window": schema.StringAttribute{
							Required:    true,
							Description: "A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.",
						},
					},
				},
			},
			"alerting": schema.ListNestedBlock{
				MarkdownDescription: `Configures the alerting rules that will be generated for each
				time window associated with the SLO. Grafana SLOs can generate
				alerts when the short-term error budget burn is very high, the
				long-term error budget burn rate is high, or when the remaining
				error budget is below a certain threshold. Annotations and Labels support templating.`,
				NestedObject: schema.NestedBlockObject{
					Blocks: map[string]schema.Block{
						"label": schema.ListNestedBlock{
							MarkdownDescription: "Labels will be attached to all alerts generated by any of these rules.",
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Required:    true,
										Description: "Key for filtering and identification",
									},
									"value": schema.StringAttribute{
										Required:    true,
										Description: "Templatable value",
									},
								},
							},
						},
						"annotation": schema.ListNestedBlock{
							MarkdownDescription: "Annotations will be attached to all alerts generated by any of these rules.",
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Required:    true,
										Description: "Key for filtering and identification",
									},
									"value": schema.StringAttribute{
										Required:    true,
										Description: "Templatable value",
									},
								},
							},
						},
						"fastburn": schema.ListNestedBlock{
							MarkdownDescription: "Alerting Rules generated for Fast Burn alerts",
							NestedObject: schema.NestedBlockObject{
								Blocks: map[string]schema.Block{
									"label": schema.ListNestedBlock{
										MarkdownDescription: "Labels to attach only to Fast Burn alerts.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"key": schema.StringAttribute{
													Required:    true,
													Description: "Key for filtering and identification",
												},
												"value": schema.StringAttribute{
													Required:    true,
													Description: "Templatable value",
												},
											},
										},
									},
									"annotation": schema.ListNestedBlock{
										MarkdownDescription: "Annotations to attach only to Fast Burn alerts.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"key": schema.StringAttribute{
													Required:    true,
													Description: "Key for filtering and identification",
												},
												"value": schema.StringAttribute{
													Required:    true,
													Description: "Templatable value",
												},
											},
										},
									},
								},
							},
						},
						"slowburn": schema.ListNestedBlock{
							MarkdownDescription: "Alerting Rules generated for Slow Burn alerts",
							NestedObject: schema.NestedBlockObject{
								Blocks: map[string]schema.Block{
									"label": schema.ListNestedBlock{
										MarkdownDescription: "Labels to attach only to Slow Burn alerts.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"key": schema.StringAttribute{
													Required:    true,
													Description: "Key for filtering and identification",
												},
												"value": schema.StringAttribute{
													Required:    true,
													Description: "Templatable value",
												},
											},
										},
									},
									"annotation": schema.ListNestedBlock{
										MarkdownDescription: "Annotations to attach only to Slow Burn alerts.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"key": schema.StringAttribute{
													Required:    true,
													Description: "Key for filtering and identification",
												},
												"value": schema.StringAttribute{
													Required:    true,
													Description: "Templatable value",
												},
											},
										},
									},
								},
							},
						},
						"advanced_options": schema.ListNestedBlock{
							MarkdownDescription: "Advanced Options for Alert Rules",
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"min_failures": schema.Int64Attribute{
										Optional:    true,
										Description: "Minimum number of failed events to trigger an alert",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *sloResource) ConfigValidators(ctx context.Context) []resource.ConfigValidator {
	return []resource.ConfigValidator{
		&requiredBlockValidator{
			blockName: "destination_datasource",
		},
		&requiredBlockValidator{
			blockName: "query",
		},
		&requiredBlockValidator{
			blockName: "objectives",
		},
	}
}

func (r *sloResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan sloResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	sloModel, diags := packSloResourceModel(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Check if this SLO has Asserts provenance and create a custom client if needed
	apiClient := r.client
	if hasAssertsProvenanceLabel(sloModel.Labels) {
		apiClient = createAssertsSLOClient(r.client)
	}

	apiReq := apiClient.DefaultAPI.V1SloPost(ctx).SloV00Slo(sloModel)
	response, _, err := apiReq.Execute()
	if err != nil {
		detail := err.Error()
		if apiErr, ok := err.(*slo.GenericOpenAPIError); ok {
			detail = fmt.Sprintf("%s\n\nResponse body:\n%s", err.Error(), string(apiErr.Body()))
		}
		resp.Diagnostics.AddError(
			"Unable to create SLO",
			"Could not create SLO: "+detail,
		)
		return
	}

	// Read back the created SLO to get all computed fields
	data, readDiags := r.readSLO(ctx, response.Uuid)
	resp.Diagnostics.Append(readDiags...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, data)...)
}

func (r *sloResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state sloResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	sloID := state.ID.ValueString()
	if sloID == "" {
		resp.State.RemoveResource(ctx)
		return
	}

	data, diags := r.readSLO(ctx, sloID)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		// Check if it's a not found error by looking for 404 in the diagnostics
		for _, d := range resp.Diagnostics {
			if d.Summary() == "SLO Not Found" {
				resp.State.RemoveResource(ctx)
				resp.Diagnostics = diag.Diagnostics{} // Clear diagnostics since we're handling 404
				return
			}
		}
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, data)...)
}

func (r *sloResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan sloResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var state sloResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	sloID := state.ID.ValueString()

	sloModel, diags := packSloResourceModel(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Check if this SLO has Asserts provenance and create a custom client if needed
	apiClient := r.client
	if hasAssertsProvenanceLabel(sloModel.Labels) {
		apiClient = createAssertsSLOClient(r.client)
	}

	apiReq := apiClient.DefaultAPI.V1SloIdPut(ctx, sloID).SloV00Slo(sloModel)
	_, err := apiReq.Execute()
	if err != nil {
		detail := err.Error()
		if apiErr, ok := err.(*slo.GenericOpenAPIError); ok {
			detail = fmt.Sprintf("%s\n\nResponse body:\n%s", err.Error(), string(apiErr.Body()))
		}
		resp.Diagnostics.AddError(
			"Unable to Update SLO",
			"Could not update SLO: "+detail,
		)
		return
	}

	// Read back the updated SLO
	data, readDiags := r.readSLO(ctx, sloID)
	resp.Diagnostics.Append(readDiags...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, data)...)
}

func (r *sloResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state sloResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	sloID := state.ID.ValueString()

	apiReq := r.client.DefaultAPI.V1SloIdDelete(ctx, sloID)
	_, err := apiReq.Execute()
	if err != nil {
		detail := err.Error()
		if apiErr, ok := err.(*slo.GenericOpenAPIError); ok {
			detail = fmt.Sprintf("%s\n\nResponse body:\n%s", err.Error(), string(apiErr.Body()))
		}
		resp.Diagnostics.AddError(
			"Unable to Delete SLO",
			"Could not delete SLO: "+detail,
		)
	}
}

func (r *sloResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}

// readSLO fetches an SLO by ID and returns the resource model
func (r *sloResource) readSLO(ctx context.Context, sloID string) (*sloResourceModel, diag.Diagnostics) {
	var diags diag.Diagnostics

	apiReq := r.client.DefaultAPI.V1SloIdGet(ctx, sloID)
	apiSlo, httpResp, err := apiReq.Execute()
	if err != nil {
		if httpResp != nil && httpResp.StatusCode == 404 {
			diags.AddError("SLO Not Found", fmt.Sprintf("SLO with ID %s was not found", sloID))
			return nil, diags
		}
		detail := err.Error()
		if apiErr, ok := err.(*slo.GenericOpenAPIError); ok {
			detail = fmt.Sprintf("%s\n\nResponse body:\n%s", err.Error(), string(apiErr.Body()))
		}
		diags.AddError("Unable to read SLO", detail)
		return nil, diags
	}

	data, convertDiags := unpackSloToResourceModel(ctx, apiSlo)
	diags.Append(convertDiags...)
	if diags.HasError() {
		return nil, diags
	}

	return data, nil
}

// hasAssertsProvenanceLabel checks if the SLO has the grafana_slo_provenance=asserts label
func hasAssertsProvenanceLabel(labels []slo.SloV00Label) bool {
	for _, label := range labels {
		if label.Key == AssertsProvenanceLabel && label.Value == AssertsProvenanceValue {
			return true
		}
	}
	return false
}

// createAssertsSLOClient creates a new SLO client with Asserts headers
func createAssertsSLOClient(baseClient *slo.APIClient) *slo.APIClient {
	// Create a new configuration with the Asserts header
	config := slo.NewConfiguration()

	// Copy the base client configuration
	config.Host = baseClient.GetConfig().Host
	config.Scheme = baseClient.GetConfig().Scheme
	config.HTTPClient = baseClient.GetConfig().HTTPClient

	// Copy existing headers BUT exclude the Terraform provider header
	// The API checks Terraform header first, so we must remove it to allow Asserts provenance
	config.DefaultHeader = make(map[string]string)
	for k, v := range baseClient.GetConfig().DefaultHeader {
		// Skip the Terraform provider header
		if k == "Grafana-Terraform-Provider" {
			continue
		}
		config.DefaultHeader[k] = v
	}
	// Add the Asserts header which will now be checked by the API
	config.DefaultHeader[AssertsRequestHeader] = "true"

	return slo.NewAPIClient(config)
}

func listSlos(ctx context.Context, client *common.Client, data any) ([]string, error) {
	sloClient := client.SLOClient
	if sloClient == nil {
		return nil, fmt.Errorf("client not configured for SLO API")
	}

	slolist, _, err := sloClient.DefaultAPI.V1SloGet(ctx).Execute()
	if err != nil {
		return nil, err
	}

	var ids []string
	for _, slo := range slolist.Slos {
		ids = append(ids, slo.Uuid)
	}
	return ids, nil
}

// ValidateGrafanaQuery validates that grafana_queries is valid JSON with required fields
func ValidateGrafanaQuery(value string) error {
	var gmrQuery []map[string]any
	err := json.Unmarshal([]byte(value), &gmrQuery)
	if err != nil {
		return fmt.Errorf("expected grafana queries to be valid JSON format")
	}

	if len(gmrQuery) == 0 {
		return fmt.Errorf("expected grafana queries to have at least one query")
	}

	for _, queryObj := range gmrQuery {
		refID, ok := queryObj["refId"]
		if !ok {
			obj, _ := json.Marshal(queryObj)
			return fmt.Errorf("expected grafana query to have a 'refId' field (%s)", obj)
		}

		source, ok := queryObj["datasource"]
		if !ok {
			return fmt.Errorf("expected grafana query to have a 'datasource' field (refId:%s)", refID)
		}

		s, ok := source.(map[string]any)
		if !ok {
			return fmt.Errorf("expected grafana query datasource to be an object (refId:%s)", refID)
		}

		if _, ok := s["type"]; !ok {
			return fmt.Errorf("expected grafana query datasource field to have a 'type' field (refId:%s)", refID)
		}
		if _, ok := s["uid"]; !ok {
			return fmt.Errorf("expected grafana query datasource field to have a 'uid' field (refId:%s)", refID)
		}
	}
	return nil
}

// ValidatePrometheusWindow validates that window is a valid Prometheus duration
func ValidatePrometheusWindow(value string) error {
	matched, _ := regexp.MatchString(`^\d+(ms|s|m|h|d|w|y)$`, value)
	if !matched {
		return fmt.Errorf("objective window must be a Prometheus-parsable time duration")
	}
	return nil
}

// requiredBlockValidator validates that a required block is present in the configuration
type requiredBlockValidator struct {
	blockName string
}

func (v *requiredBlockValidator) Description(ctx context.Context) string {
	return fmt.Sprintf("Validates that the %s block is present", v.blockName)
}

func (v *requiredBlockValidator) MarkdownDescription(ctx context.Context) string {
	return fmt.Sprintf("Validates that the `%s` block is present", v.blockName)
}

func (v *requiredBlockValidator) ValidateResource(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var blockList types.List

	resp.Diagnostics.Append(req.Config.GetAttribute(ctx, path.Root(v.blockName), &blockList)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Check if the block is null or has zero elements
	if blockList.IsNull() || len(blockList.Elements()) == 0 {
		resp.Diagnostics.AddAttributeError(
			path.Root(v.blockName),
			fmt.Sprintf("Insufficient %s blocks", v.blockName),
			fmt.Sprintf("At least 1 \"%s\" blocks are required.", v.blockName),
		)
	}
}
